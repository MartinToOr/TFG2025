<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa de Valencia - Metro y Valenbisi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
    
<style>


/* 

TO DO:

			Borrar rutas con la lupita!!
			esperar a todas para imprimir la tabla

*/


    #map {
        width: 100%;
        height: 100vh;
        position: relative;
    }

    .logo { 
        height: 200px;
        width: auto;
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 1000; 
        pointer-events: none; /* Permite clics en el mapa debajo */
    }

    .distance-info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
    }

    .transport-selector {
        position: absolute;
        bottom: 50px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
    }
    

	
.directions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 400px;
    position: absolute;
    top: 20px;
    left: 70px;
    background: rgba(73, 163, 13, 0.8); /* Verde con opacidad */
    padding: 15px;
    border-radius: 8px;
    z-index: 1000;
}

/* Contenedor de cada input y su label */
.input-container {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
}

/* Estilo para los labels */
.input-container label {
    width: 60px; /* Ancho fijo para alinear los textos */
    font-weight: bold;
    color: white;
}

/* Estilo para los inputs */
.input-container input {
    flex-grow: 1;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 5px;
    outline: none;
}

/* Estilo del bot√≥n de b√∫squeda (lupa) */
.search-icon {
    cursor: pointer;
    font-size: 20px;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    transition: background 0.3s ease;
    margin-left: auto; /* Alinea a la derecha */
}

/* Hover: Fondo blanco cuando pasas el rat√≥n */
.search-icon:hover {
    background: white;
}


	

    
</style>
</head>
<body>
  <div id="map"></div>
  <div class="distance-info" id="distance-info">Seleccione dos puntos para calcular la distancia.</div>

  <header>
      <img src="img/logo1.png" alt="Logo" class="logo">
  </header>

  <div class="transport-selector">
      <div class="control-panel">
          <label for="transport-select">Seleccionar una vista del mapa:</label>
          <select id="transport-select">
              <option value="none" selected>Mapa simple</option>
              
              <option value="metro">Metro</option>
              <option value="bus">Autobuses</option>
              <option value="bici">Valenbisi</option>
          </select>
      </div>

      
  </div>
  
  
<div class="directions">
    <div class="input-container">
        <label for="origin-input">Origen</label>
        <input id="origin-input" type="text" placeholder="Elige un punto de origen">
    </div>

    <div class="input-container">
        <label for="destination-input">Destino</label>
        <input id="destination-input" type="text" placeholder="Elige un destino">
    </div>

    <span id="set-directions" class="search-icon">üîç</span>
</div>




  <!-- Bloque de direcciones -->

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCzX88lbn1Xa_pouaPX4k_4IjRuJsjB064&libraries=geometry,places"></script>


<script>
    let map = L.map('map', {
        minZoom: 10,
        maxBounds: [[39.059009, -1.437558], [39.937940, 0.747262]]
    }).setView([39.4699, -0.3763], 13);

    // Capa base de Tracestack Topo
    L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://hotosm.org">Humanitarian OpenStreetMap Team</a>'
    }).addTo(map);

        let pointA = null;
        let pointB = null;
        let markerA = null;
        let markerB = null;
        let routePolyline = [];
        let markers = []; // Guarda todos los marcadores
        let valenbisiStations = []; // Almacenar estaciones de Valenbisi
        let transportMode = "TRANSIT";

        var directionsService = new google.maps.DirectionsService();
        var service = new google.maps.DistanceMatrixService();

        // Funci√≥n para crear un marcador en Leaflet
        function createMarker(latlng, color) {
          return L.marker(latlng, {
            icon: L.icon({
              iconUrl: `https://maps.google.com/mapfiles/ms/icons/${color}-dot.png`,
              iconSize: [32, 32],
              iconAnchor: [16, 32]
            })
          }).addTo(map);
        }

        // Funci√≥n principal que calcula distancias y rutas
        function calculateDistanceAndRoute() {
          if (!pointA || !pointB) return;

          const origin = new google.maps.LatLng(pointA.lat, pointA.lng);
          const destination = new google.maps.LatLng(pointB.lat, pointB.lng);

          if (transportMode === "COMPARA") {
        	  let modes = ["WALKING", "DRIVING", "BICYCLING", "BICI", "METRO", "BUS"];
        	    let results = [];
        	    let completedRequests = 0;

        	    modes.forEach(mode => {
        	        if (mode === "BICI") {
        	            if (!valenbisiStations || valenbisiStations.length === 0) {
        	                console.error("No hay estaciones de Valenbisi disponibles.");
        	                completedRequests++;
        	                if (completedRequests === modes.length) {
        	                    mostrarTablaResultados(results);
        	                }
        	                return;
        	            }

        	            findNearestStationOptimized(pointA, function(startStation) {
        	                if (!startStation) {
        	                    console.error("No se encontr√≥ estaci√≥n inicial cerca de pointA.");
        	                    completedRequests++;
        	                    return;
        	                }

        	                findNearestStationOptimized(pointB, function(endStation) {
        	                    if (!endStation) {
        	                        console.error("No se encontr√≥ estaci√≥n final cerca de pointB.");
        	                        completedRequests++;
        	                        return;
        	                    }

        	                    let walkingRoute1 = { origin: pointA, destination: startStation };
        	                    let cyclingRoute  = { origin: startStation, destination: endStation };
        	                    let walkingRoute2 = { origin: endStation, destination: pointB };

        	                    let distanciaTotal = 0;
        	                    let duracionTotal = 0;

        	                    calculateRouteBici(walkingRoute1, "WALKING", "green", function(distancia1, duracion1) {
        	                    	console.log("desde solo el calculate: " + distancia1);
        	                        distanciaTotal += distancia1;
        	                        duracionTotal += duracion1;

        	                        calculateRouteBici(cyclingRoute, "BICYCLING", "blue", function(distancia2, duracion2) {
        	                        	console.log("desde solo el calculate: " + distancia2);
        	                            distanciaTotal += distancia2;
        	                            duracionTotal += duracion2;

        	                            calculateRouteBici(walkingRoute2, "WALKING", "green", function(distancia3, duracion3) {
        	                            	console.log("desde solo el calculate: " + distancia3);
        	                                distanciaTotal += distancia3;
        	                                duracionTotal += duracion3;
        	                                
        	                                
        	                                
        	                                console.log(distanciaTotal); 


        	                                results.push({
        	                                    mode: "Valenbici",
        	                                    distanceText: (distanciaTotal / 1000).toFixed(2) + " km",
        	                                    durationText: Math.round(duracionTotal / 60) + " min",
        	                                    co2Emissions: "0g/km"
        	                                });

        	                                completedRequests++;
        	                                if (completedRequests === modes.length) {
        	                                    mostrarTablaResultados(results);
        	                                }
        	                            });
        	                        });
        	                    });
        	                });
        	            });
        	        }
        	        else if (mode === "METRO") {
        	            let startMetroStation = findNearestMetroStation(pointA);
        	            if (!startMetroStation) {
        	                console.error("No se encontr√≥ estaci√≥n de metro cercana a pointA.");
        	                completedRequests++;
        	                return;
        	            }

        	            let endMetroStation = findNearestMetroStation(pointB);
        	            if (!endMetroStation) {
        	                console.error("No se encontr√≥ estaci√≥n de metro cercana a pointB.");
        	                completedRequests++;
        	                return;
        	            }

        	            let metroRoute = calculateMetroRoute(startMetroStation, endMetroStation);
        	            if (!metroRoute || metroRoute.length === 0) {
        	                console.error("No se pudo calcular la ruta de metro entre las estaciones.");
        	                completedRequests++;
        	                return;
        	            }

        	            let walkingRoute1 = { origin: pointA, destination: startMetroStation };
        	            let walkingRoute2 = { origin: endMetroStation, destination: pointB };

        	            let distanciaTotal = lastMetroDistance; // Se calcula dentro de calculateMetroRoute
        	            let duracionTotal = (lastMetroDistance / 500) * 60; // Aproximando 500 m/min de velocidad media

        	            calculateRouteBici(walkingRoute1, "WALKING", "green", function(distancia, duracion) {
        	                distanciaTotal += distancia;
        	                duracionTotal += duracion;
        	            });

        	            calculateRouteBici(walkingRoute2, "WALKING", "green", function(distancia, duracion) {
        	                distanciaTotal += distancia;
        	                duracionTotal += duracion;
							
 	                
        	                
        	                results.push({
        	                    mode: "Metro",
        	                    distanceText: (distanciaTotal / 1000).toFixed(2) + " km",
        	                    durationText: Math.round(duracionTotal / 60) + " min",
        	                    co2Emissions: "10g/km" // Valor estimado
        	                });

        	                
        	                if (++completedRequests === modes.length) {
        	                    mostrarTablaResultados(results);
        	                }
        	            });

        	           // drawMetroRoute(metroRoute, "red");

        	        }
        	        else if (mode === "BUS") {
        	            const distanceRequest = {
        	                origins: [origin],
        	                destinations: [destination],
        	                travelMode: google.maps.TravelMode.TRANSIT,
        	                unitSystem: google.maps.UnitSystem.METRIC,
        	                transitOptions: { modes: ['BUS'] }
        	            };

        	            service.getDistanceMatrix(distanceRequest, (response, status) => {
        	                if (status === "OK" && response.rows.length > 0) {
        	                    let distanceText = response.rows[0].elements[0].distance.text;
        	                    let durationText = response.rows[0].elements[0].duration.text;

        	                    results.push({
        	                        mode: "Autob√∫s",
        	                        distanceText: distanceText,
        	                        durationText: durationText,
        	                        co2Emissions: "80g/km" // Valor estimado
        	                    });

        	                    if (++completedRequests === modes.length) {
        	                        mostrarTablaResultados(results);
        	                    }
        	                } else {
        	                    console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
        	                    completedRequests++;
        	                }
        	            });

        	            const directionsRequest = {
        	                origin: origin,
        	                destination: destination,
        	                travelMode: google.maps.TravelMode.TRANSIT,
        	                transitOptions: { modes: ['BUS'] }
        	            };

        	            directionsService.route(directionsRequest, (result, status) => {
        	                if (status === "OK") {
        	                 //   console.log(result);



        	                    const steps = result.routes[0].legs[0].steps;

        	                    steps.forEach(step => {
        	                        let color = step.travel_mode === 'TRANSIT' ? 'blue' : 'green';

        	                        const stepCoords = decodePolyline(step.polyline.points).map(point => [point.lat, point.lng]);

        	                       
        	                    });

        	                    
        	                } else {
        	                    console.error("Error al obtener la ruta de Google Maps Directions:", status);
        	                }
        	            });

        	        }
        	        else {
        	            const request = {
        	                origins: [origin],
        	                destinations: [destination],
        	                travelMode: google.maps.TravelMode[mode],
        	                unitSystem: google.maps.UnitSystem.METRIC
        	            };

        	            service.getDistanceMatrix(request, (response, status) => {
        	                if (status === "OK" && response.rows.length > 0) {
        	                    let element = response.rows[0].elements[0];
        	                    let distanceText = element.distance.text;
        	                    let durationText = element.duration.text;
        	                    let co2Emissions = mode === "DRIVING" ? "140g/km" : "0g/km";

        	                    let modeTranslation = {
        	                        "WALKING": "Andando",
        	                        "BICYCLING": "Bicicleta",
        	                        "DRIVING": "Coche"
        	                    };

        	                    results.push({ mode: modeTranslation[mode], distanceText, durationText, co2Emissions });
        	                } else {
        	                    console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
        	                }
        	                completedRequests++;
        	                if (completedRequests === modes.length) {
        	                    mostrarTablaResultados(results);
        	                }
        	            });
        	        }
        	    });
        	}

          else if (transportMode === "BICI") {
            if (!valenbisiStations || valenbisiStations.length === 0) {
              console.error("No hay estaciones de Valenbisi disponibles.");
              return;
            }
            
            document.getElementById("transport-select").value = "bici";
            toggleTransport("bici");

            // Aqu√≠ todo el c√≥digo dependiente de las estaciones se coloca dentro de la cadena de callbacks
            findNearestStationOptimized(pointA, function(startStation) {
              if (!startStation) {
                console.error("No se encontr√≥ estaci√≥n inicial cerca de pointA.");
                return;
              }
              //console.log("startStation asignada:", startStation);

              findNearestStationOptimized(pointB, function(endStation) {
                if (!endStation) {
                  console.error("No se encontr√≥ estaci√≥n final cerca de pointB.");
                  return;
                }
               // console.log("endStation asignada:", endStation);

                // Definir las rutas:
                let walkingRoute1 = { origin: pointA, destination: startStation };
               console.log("Origen: ", pointA, " destino: ", startStation);
                let cyclingRoute  = { origin: startStation, destination: endStation };
                let walkingRoute2 = { origin: endStation, destination: pointB };

                // Calcular y dibujar las rutas:
                calculateAndDrawRoute(walkingRoute1, "WALKING", "green");  // Desde pointA hasta la estaci√≥n de inicio
                calculateAndDrawRoute(cyclingRoute,  "BICYCLING", "blue");   // En bici entre estaciones
                calculateAndDrawRoute(walkingRoute2, "WALKING", "green");    // Desde la estaci√≥n final hasta pointB
                
                moveToMidPointMarkers(pointA, pointB);
              });
            });
          }
          else if (transportMode === "METRO") {
        	  document.getElementById("transport-select").value = "metro";
        	  toggleTransport("metro");

        	  // 1. Encontrar la estaci√≥n de metro m√°s cercana a pointA y pointB
        	  let startMetroStation = findNearestMetroStation(pointA);
        	  if (!startMetroStation) {
        	    console.error("No se encontr√≥ estaci√≥n de metro cercana a pointA.");
        	    return;
        	  }

        	  let endMetroStation = findNearestMetroStation(pointB);
        	  if (!endMetroStation) {
        	    console.error("No se encontr√≥ estaci√≥n de metro cercana a pointB.");
        	    return;
        	  }

        	  // 2. Calcular la ruta de metro entre la estaci√≥n de inicio y la de fin
        	  let metroRoute = calculateMetroRoute(startMetroStation, endMetroStation);
        	  if (!metroRoute || metroRoute.length === 0) {
        	    console.error("No se pudo calcular la ruta de metro entre las estaciones.");
        	    return;
        	  }

        	  // 3. Definir y dibujar los tramos:
        	  // a) Ruta caminando desde pointA hasta la estaci√≥n de inicio de metro
        	  let walkingRoute1 = {
        	    origin: pointA,
        	    destination: startMetroStation 
        	  };
        	  calculateAndDrawRoute(walkingRoute1, "WALKING", "green");

        	  // b) Ruta de metro (dibujada como polil√≠nea) siguiendo las estaciones intermedias
        	  drawMetroRoute(metroRoute, "red");

        	  // c) Ruta caminando desde la estaci√≥n final de metro hasta pointB
        	  let walkingRoute2 = {
        	    origin: endMetroStation,
        	    destination: pointB
        	  };
        	  calculateAndDrawRoute(walkingRoute2, "WALKING", "green");

        	  moveToMidPointMarkers(pointA, pointB);
        	}
          else  if (transportMode === "BUS") {
        	  
        	  document.getElementById("transport-select").value = "bus";
        	  toggleTransport("bus");
            // Resto de modos de transporte (por ejemplo, TRANSIT, DRIVING, etc.)
        	  const distanceRequest = {
        			  origins: [origin],
        			  destinations: [destination],
        			  travelMode: google.maps.TravelMode[transportMode] || "TRANSIT",
        			  unitSystem: google.maps.UnitSystem.METRIC,
        			  transitOptions: {
        			    modes: ['BUS']  
        			  }
        			};

        			service.getDistanceMatrix(distanceRequest, (response, status) => {
        			  if (status === "OK" && response.rows.length > 0) {
        			    let distanceText = response.rows[0].elements[0].distance.value;
        			    document.getElementById('distance-info').innerText = `Distancia: ${(distanceText / 1000).toFixed(2)} km`;
        			  } else {
        			    console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
        			  }
        			});

        			const directionsRequest = {
        			  origin: origin,
        			  destination: destination,
        			  travelMode: google.maps.TravelMode[transportMode] || "TRANSIT",
        			  transitOptions: {
        			    modes: ['BUS']  // Forzar solo el autob√∫s como modo de transporte
        			  }
        			};

        			directionsService.route(directionsRequest, (result, status) => {
        				  if (status === "OK") {
        				    console.log(result);

        				    // Limpiar las rutas anteriores
        				    if (routePolyline) {
        				      routePolyline.forEach(item => {
        				        map.removeLayer(item);
        				      });
        				    }

        				    // Recorrer los pasos de la ruta
        				    const steps = result.routes[0].legs[0].steps;

        				    // Recorrer cada paso y dibujar la polil√≠nea correspondiente seg√∫n el modo de transporte
        				    steps.forEach(step => {
        				      let color = 'green';  // Color por defecto (caminar)
								console.log(step.travel_mode);
        				      // Si el paso es de tipo 'TRANSIT' (transporte p√∫blico)
        				      if (step.travel_mode === 'TRANSIT') {

        				            color = 'blue';
        				       
        				      }

        				      // Decodificar el polyline de Google Maps (para obtener los puntos de la ruta)
        				      const stepCoords = decodePolyline(step.polyline.points).map(point => [point.lat, point.lng]);

        				      // Dibujar la polil√≠nea del paso con el color correspondiente
        				      routePolyline.push(L.polyline(stepCoords, { color: color, weight: 4 }).addTo(map));
        				    });

        				    // Funci√≥n para mover el mapa al punto medio de las rutas
        				    moveToMidPointMarkers(pointA, pointB);
        				  } else {
        				    console.error("Error al obtener la ruta de Google Maps Directions:", status);
        				  }
        				});
          }
         
        	  
              else {
            	  document.getElementById("transport-select").value = "none";
            	  toggleTransport("none");
                  // Resto de modos de transporte (por ejemplo, TRANSIT, DRIVING, etc.)
                  const distanceRequest = {
                    origins: [origin],
                    destinations: [destination],
                    travelMode: google.maps.TravelMode[transportMode] || "TRANSIT",
                    unitSystem: google.maps.UnitSystem.METRIC
                  };

                  service.getDistanceMatrix(distanceRequest, (response, status) => {
                    if (status === "OK" && response.rows.length > 0) {
                      let distanceText = response.rows[0].elements[0].distance.text;
                      document.getElementById('distance-info').innerText = `Distancia: ${distanceText}`;
                    } else {
                      console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
                    }
                  });

                  const directionsRequest = {
                    origin: origin,
                    destination: destination,
                    travelMode: google.maps.TravelMode[transportMode] || "TRANSIT"
                  };

                  directionsService.route(directionsRequest, (result, status) => {
                    if (status === "OK") {
                      if (routePolyline) {
                        map.removeLayer(routePolyline);
                      }
                      moveToMidPointMarkers(pointA, pointB);
                      const routeCoords = result.routes[0].overview_path.map(point => [point.lat(), point.lng()]);
                      routePolyline.push(L.polyline(routeCoords, { color: 'blue', weight: 4 }).addTo(map));
                    } else {
                      console.error("Error al obtener la ruta de Google Maps Directions:", status);
                    }
                  });
                } 
        	  
          
        }
        
        function decodePolyline(encoded) {
        	  const len = encoded.length;
        	  const points = [];
        	  let index = 0;
        	  let lat = 0;
        	  let lng = 0;

        	  while (index < len) {
        	    let b, shift = 0, result = 0;
        	    do {
        	      b = encoded.charCodeAt(index++) - 63;
        	      result |= (b & 0x1f) << shift;
        	      shift += 5;
        	    } while (b >= 0x20);
        	    lat += (result & 1) ? ~(result >> 1) : (result >> 1);

        	    shift = 0;
        	    result = 0;
        	    do {
        	      b = encoded.charCodeAt(index++) - 63;
        	      result |= (b & 0x1f) << shift;
        	      shift += 5;
        	    } while (b >= 0x20);
        	    lng += (result & 1) ? ~(result >> 1) : (result >> 1);

        	    points.push({ lat: lat / 1E5, lng: lng / 1E5 });
        	  }
        	  return points;
        	}

        
        
        // ‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨
        
        
function findNearestMetroStation(point) {
  let nearest = null;
  //console.log(stationUsage);
  let minDistance = Infinity;
  Object.keys(stationUsage).forEach(stationName => {
    let station = stationUsage[stationName];
    console.log(station);
    let dist = haversineDistance(point, station);
    if (dist < minDistance) {
      minDistance = dist;
      nearest = station;
    }
  });
  console.log(nearest);
  return nearest;
}

// Funci√≥n sencilla para calcular la distancia (puedes reemplazarla por la f√≥rmula de Haversine si lo prefieres)


/*
  Calcula la ruta de metro entre dos estaciones.
  - Si ambas estaciones comparten l√≠nea, se extrae el tramo correspondiente.
  - Si no comparten l√≠nea, se busca una estaci√≥n de transbordo (que pertenezca a una l√≠nea com√∫n a ambas)
    y se arma la ruta en dos tramos.
*/
let lastMetroDistance = 0;
let distancia_total = 0;
let segundos_total = 0;

function calculateMetroRoute(startStation, endStation) {
  let route = [];
  
  // 1. Verificar si comparten alguna l√≠nea
  let commonLine = startStation.lines.find(line => endStation.lines.includes(line));
  if (commonLine) {
    console.log("Est√°n en la misma l√≠nea");
    route = getRouteForLine(commonLine, startStation.name, endStation.name);
  } else {
    console.log("NO est√°n en la misma l√≠nea");
    // 2. Buscar estaci√≥n de transbordo
    let transferStationName = null;
    startStation.lines.forEach(lineA => {
      metroStations[lineA].forEach(stationName => {
        if (
          stationUsage[stationName] &&
          stationUsage[stationName].lines.some(line => endStation.lines.includes(line))
        ) {
          if (!transferStationName) transferStationName = stationName;
        }
      });
    });
    if (!transferStationName) {
      return [];
    }

    // 3. Calcular tramo A -> Transfer
    let lineA = startStation.lines.find(line => stationUsage[transferStationName].lines.includes(line));
    let routeA = getRouteForLine(lineA, startStation.name, transferStationName);

    // 4. Calcular tramo Transfer -> B
    let lineB = endStation.lines.find(line => stationUsage[transferStationName].lines.includes(line));
    let routeB = getRouteForLine(lineB, transferStationName, endStation.name);

    // 5. Quitar estaci√≥n duplicada y unir rutas
    routeB.shift();
    route = routeA.concat(routeB);
  }

  // 6. Calcular la distancia total del recorrido (en metros) y almacenarla en lastMetroDistance
  let totalDistKm = 0;  
  for (let i = 0; i < route.length - 1; i++) {
    // haversineDistance usa {lat, lng}, pero en route tenemos {lat, lon}.
    // Convertimos 'lon' a 'lng' para cada punto.
    const coord1 = { lat: route[i].lat, lng: route[i].lon };
    const coord2 = { lat: route[i + 1].lat, lng: route[i + 1].lon };
    totalDistKm += haversineDistance(coord1, coord2); // Devuelve distancia en km
  }
  lastMetroDistance = totalDistKm * 1000; // Lo convertimos a metros
  distancia_total += lastMetroDistance;
  console.log("Distancia total en la ruta de metro (m):", lastMetroDistance);

  // 7. Retornar la secuencia de estaciones, pero no la distancia
  return route;
}

/*
  Devuelve la ruta (arreglo de objetos con nombre, lat y lon) para una l√≠nea determinada,
  desde startName hasta endName siguiendo el orden definido en metroStations.
*/
function getRouteForLine(line, startName, endName) {
  let stationsOrdered = metroStations[line];
  let startIndex = stationsOrdered.indexOf(startName);
  let endIndex = stationsOrdered.indexOf(endName);
  if (startIndex === -1 || endIndex === -1) {
    console.error("Estaci√≥n no encontrada en la l√≠nea " + line);
    return [];
  }
  let routeNames;
  if (startIndex <= endIndex) {
    routeNames = stationsOrdered.slice(startIndex, endIndex + 1);
  } else {
    routeNames = stationsOrdered.slice(endIndex, startIndex + 1).reverse();
  }
  return routeNames.map(name => ({ name: name, lat: stationUsage[name].lat, lon: stationUsage[name].lon }));
}

// Dibuja la ruta de metro como una polil√≠nea en el mapa
function drawMetroRoute(route, color) {
  const latlngs = route.map(station => [station.lat, station.lon]);
  routePolyline.push(L.polyline(latlngs, { color: color, weight: 5, dashArray: "5,10" }).addTo(map));
}
        
        
        // ‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨‚Ç¨
        
        
        

        // Funci√≥n para calcular y dibujar una ruta usando Directions y Distance Matrix
        function calculateAndDrawRoute(route, mode, color) {
          // Convertir y validar las coordenadas
          const originLat = parseFloat(route.origin.lat);
          const destinationLat = parseFloat(route.destination.lat);
        
          let originLng;
          let destinationLng;
          
          if(route.origin.lng == null){
        	  originLng = parseFloat(route.origin.lon);
          }
          else{
              originLng = parseFloat(route.origin.lng);
          }
          
         if(route.destination.lng == null){
        	  destinationLng =  parseFloat(route.destination.lon);
          }
         else{
        	 destinationLng =  parseFloat(route.destination.lng);
         }
         

          if (isNaN(originLat) || isNaN(originLng) || isNaN(destinationLat) || isNaN(destinationLng)) {
            console.error("Coordenadas inv√°lidas en la ruta:", route);
            return;
          }

          const request = {
            origin: new google.maps.LatLng(originLat, originLng),
            destination: new google.maps.LatLng(destinationLat, destinationLng),
            travelMode: google.maps.TravelMode[mode]
          };

           // Inicializamos la variable

          // Usar route.origin y route.destination (ya convertidos) en la solicitud
          const distanceRequest = {
            origins: [new google.maps.LatLng(originLat, originLng)],
            destinations: [new google.maps.LatLng(destinationLat, destinationLng)],
            travelMode: google.maps.TravelMode[mode],
            unitSystem: google.maps.UnitSystem.METRIC
          };

          let distanceValue = 0;
        	  
          service.getDistanceMatrix(distanceRequest, (response, status) => {
            if (status === "OK" && response.rows.length > 0) {
            	distanceValue = response.rows[0].elements[0].distance.value;
            	let duarationValue = response.rows[0].elements[0].duration.value;
              console.log( "desde el draw:" + distanceValue);
              console.log( "ruta " + response);
              distancia_total += distanceValue;
              segundos_total += duarationValue;
              
              document.getElementById('distance-info').innerText = `Distancia: ${(distancia_total/1000).toFixed(2)} km`;
            } else {
              console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
            }
          });

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              let routeCoords = result.routes[0].overview_path.map(point => [point.lat(), point.lng()]);
              routePolyline.push(L.polyline(routeCoords, { color: color, weight: 4 }).addTo(map)) ;
            } else {
              console.error(`Error al calcular ruta (${mode}):`, status);
            }
          });
        }
        
        function calculateRouteBici(route, mode, color, callback) {
            const originLat = parseFloat(route.origin.lat);
            const destinationLat = parseFloat(route.destination.lat);
            
            let originLng = route.origin.lng ?? parseFloat(route.origin.lon);
            let destinationLng = route.destination.lng ?? parseFloat(route.destination.lon);

            if (isNaN(originLat) || isNaN(originLng) || isNaN(destinationLat) || isNaN(destinationLng)) {
                console.error("Coordenadas inv√°lidas en la ruta:", route);
                callback(0, 0); // Devuelve 0 si hay error
                return;
            }

            const request = {
                origin: new google.maps.LatLng(originLat, originLng),
                destination: new google.maps.LatLng(destinationLat, destinationLng),
                travelMode: google.maps.TravelMode[mode]
            };

            const distanceRequest = {
                origins: [new google.maps.LatLng(originLat, originLng)],
                destinations: [new google.maps.LatLng(destinationLat, destinationLng)],
                travelMode: google.maps.TravelMode[mode],
                unitSystem: google.maps.UnitSystem.METRIC
            };

            service.getDistanceMatrix(distanceRequest, (response, status) => {
                if (status === "OK" && response.rows.length > 0) {
                    let distanceValue = response.rows[0].elements[0].distance.value; // En metros
                    let durationValue = response.rows[0].elements[0].duration.value; // En segundos
                    
                    // Llamamos al callback con los valores obtenidos
                    callback(distanceValue, durationValue);
                } else {
                    console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
                    callback(0, 0); // Devuelve 0 si hay error
                }
            });

            directionsService.route(request, (result, status) => {
                if (status === "OK") {
                    let routeCoords = result.routes[0].overview_path.map(point => [point.lat(), point.lng()]);
           
                } else {
                    console.error(`Error al calcular ruta (${mode}):`, status);
                }
            });
        }


        // Funci√≥n para buscar la estaci√≥n de Valenbisi m√°s cercana (usando 3 candidatos aproximados)
        function findNearestStationOptimized(point, callback) {
          // 1. Calcular la distancia aproximada para cada estaci√≥n usando la f√≥rmula de haversine
          const candidates = valenbisiStations
            .map(station => {
              // Convertir las coordenadas de la estaci√≥n (normalizamos: usamos station.lat y station.lon -> station.lng)
              const candidateCoord = { lat: parseFloat(station.lat), lng: parseFloat(station.lon) };
              const approxDistance = haversineDistance(point, candidateCoord);
              return { station, approxDistance };
            })
            .sort((a, b) => a.approxDistance - b.approxDistance)
            .slice(0, 3);



          const originLatLng = new google.maps.LatLng(point.lat, point.lng);
          const destinations = candidates.map(candidate =>
            new google.maps.LatLng(parseFloat(candidate.station.lat), parseFloat(candidate.station.lon))
          );

          const distanceRequest = {
            origins: [originLatLng],
            destinations: destinations,
            travelMode: google.maps.TravelMode.WALKING,
            unitSystem: google.maps.UnitSystem.METRIC
          };

          service.getDistanceMatrix(distanceRequest, (response, status) => {
            if (status === "OK" && response.rows.length > 0) {
              const elements = response.rows[0].elements;
              let bestIndex = -1;
              let bestDistance = Infinity;

              elements.forEach((element, index) => {
                if (element.status === "OK") {
                  const walkingDistance = element.distance.value; // en metros
                  //console.log(`Distancia caminando a ${candidates[index].station.address}: ${walkingDistance} m`);
                  if (walkingDistance < bestDistance) {
                    bestDistance = walkingDistance;
                    bestIndex = index;
                  }
                } else {
                  console.warn(`No se pudo obtener la distancia para ${candidates[index].station.address}`);
                }
              });

              if (bestIndex !== -1) {
                const bestStation = candidates[bestIndex].station;
                // Normalizamos el objeto de estaci√≥n (convertimos 'lon' en 'lng')
                const normalizedStation = {
                  lat: bestStation.lat,
                  lng: bestStation.lon,
                  address: bestStation.address,
                  available: bestStation.available,
                  total: bestStation.total
                };
                console.log(`La estaci√≥n m√°s cercana es: ${normalizedStation.address} (${bestDistance} m caminando)`);
                callback(normalizedStation);
              } else {
                console.error("No se pudo determinar la estaci√≥n m√°s cercana a partir de la respuesta de Google.");
                callback(null);
              }
            } else {
              console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
              callback(null);
            }
          });
        }

        // Funci√≥n que calcula la distancia entre dos coordenadas (usando la f√≥rmula de haversine)
        function haversineDistance(coord1, coord2) {
        	
        let lng2;
        	if (coord2.lng == null){
        		lng2 = 	coord2.lon;
        	}
        	else{        		
        		lng2 = 	coord2.lng;
        	}
        	
          const R = 6371; // Radio de la Tierra en km
          const dLat = (parseFloat(coord2.lat) - parseFloat(coord1.lat)) * Math.PI / 180;
          const dLon = (parseFloat(lng2) - parseFloat(coord1.lng)) * Math.PI / 180;
          const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(parseFloat(coord1.lat) * Math.PI / 180) * Math.cos(parseFloat(coord2.lat) * Math.PI / 180) *
                    Math.sin(dLon / 2) ** 2;
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        function moveToMidPointMarkers(marker1, marker2) {
            // Calcular el punto medio
            let midLat = (marker1.lat + marker2.lat) / 2;
            let midLng = (marker1.lng + marker2.lng) / 2;

            // Crear bounds con los dos puntos
            let bounds = L.latLngBounds([marker1, marker2]);

            // Mover la c√°mara con animaci√≥n
            map.flyToBounds(bounds, {
                padding: [70, 70], // Espaciado extra alrededor
                duration: 1.5      // Duraci√≥n de la animaci√≥n en segundos
            });
        }

        map.on('click', function (e) {
            if (!pointA) {
                pointA = e.latlng;
                markerA = createMarker(pointA, "red");
                document.getElementById('distance-info').innerText = "Seleccione un nuevo punto B.";
            } else if (!pointB) {
                pointB = e.latlng;
                markerB = createMarker(pointB, "blue");
                seleccionaOpcionTransporte();
            } else {
             
                map.removeLayer(markerA);
                map.removeLayer(markerB);
                pointB = null;
                pointA = null;
               distancia_total = 0;
               segundos_total = 0;
               
                if (routePolyline) {
                	  routePolyline.forEach(item => {
                	    map.removeLayer(item);
                	  });
                      routePolyline = [];
                	}

                document.getElementById('distance-info').innerText = "Seleccione un nuevo punto A.";
            }
        });

        
        
        map.on('zoomend', function () {
            let zoom = map.getZoom();
            let size = zoom < 10 ? 7    
                     : zoom < 13 ? 10
                     : zoom < 14 ? 13
                     : zoom < 15 ? 19
                     : 25;  

            markers.forEach(marker => {
                let color = marker.tipo === "metro" ? "red" :
                            marker.tipo === "bus" ? "green" : "blue";

                let letter = marker.tipo === "metro" ? "M" :
                             marker.tipo === "bus" ? "B" : "V";

                marker.setIcon(createCustomIcon(size, letter, color));
            });
        });
        
        
        function seleccionaOpcionTransporte() {
            // Crear el modal
            let modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.display = "flex";
            modal.style.justifyContent = "center";
            modal.style.alignItems = "center";
            modal.style.zIndex = "9999"; // Asegurar que est√° delante de todo

            let modalContent = document.createElement("div");
            modalContent.style.background = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "10px";
            modalContent.style.textAlign = "center";
            modalContent.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";

            let title = document.createElement("h3");
            title.innerText = "Selecciona un modo de transporte";
            modalContent.appendChild(title);

            let botones = [
                { texto: "Andando", valor: "WALKING" },
                { texto: "Coche", valor: "DRIVING" },
                { texto: "Bicicleta", valor: "BICYCLING" },
                { texto: "Metro", valor: "METRO" },
                { texto: "Autobus", valor: "BUS" },
                { texto: "Valenbici", valor: "BICI" },
                { texto: "Comparalos todos", valor: "COMPARA" }
            ];

            botones.forEach(boton => {
                let btn = document.createElement("button");
                btn.innerText = boton.texto;
                btn.style.margin = "10px";
                btn.style.padding = "10px 20px";
                btn.style.border = "none";
                btn.style.cursor = "pointer";
                btn.style.borderRadius = "5px";
                btn.style.background = "#007bff";
                btn.style.color = "white";
                btn.onclick = function() {
                    transportMode = boton.valor;
                    document.body.removeChild(modal);
                    calculateDistanceAndRoute();
                };
                modalContent.appendChild(btn);
            });

            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
        
        
        function mostrarTablaResultados(results) {
            let modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.display = "flex";
            modal.style.justifyContent = "center";
            modal.style.alignItems = "center";
            modal.style.zIndex = "9999";

            let modalContent = document.createElement("div");
            modalContent.style.background = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "10px";
            modalContent.style.textAlign = "center";
            modalContent.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";

            let title = document.createElement("h3");
            title.innerText = "Comparaci√≥n de modos de transporte";
            modalContent.appendChild(title);

            let table = document.createElement("table");
            table.style.width = "100%";
            table.style.borderCollapse = "collapse";
            table.style.marginTop = "20px";

            let thead = document.createElement("thead");
            let headerRow = document.createElement("tr");
            ["Modo de Transporte", "Distancia", "Tiempo", "CO2 Emitido"].forEach(text => {
                let th = document.createElement("th");
                th.innerText = text;
                th.style.border = "1px solid #ddd";
                th.style.padding = "10px";
                th.style.background = "#f4f4f4";
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            let tbody = document.createElement("tbody");
            results.forEach(result => {
                let row = document.createElement("tr");
                [result.mode, result.distanceText, result.durationText, result.co2Emissions].forEach(value => {
                    let td = document.createElement("td");
                    td.innerText = value;
                    td.style.border = "1px solid #ddd";
                    td.style.padding = "10px";
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            modalContent.appendChild(table);
            
            let closeButton = document.createElement("button");
            closeButton.innerText = "Cerrar";
            closeButton.style.marginTop = "15px";
            closeButton.onclick = () => document.body.removeChild(modal);
            modalContent.appendChild(closeButton);
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
        
        function createCustomIcon(size, letter, color) {
            return L.divIcon({
                className: 'custom-icon',
                html: `<div style="
                            width: ${size}px;
                            height: ${size}px;
                            background: ${color};
                            color: white;
                            text-align: center;
                            font-weight: bold;
                            font-size: ${size / 2}px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;">
                        ${letter}
                    </div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });
        }
        
        let metroLines = {}; 
        const metroColors = {
            "1": "#E4BE36", 
            "2": "#B4397F", 
            "3": "#B11D2F", 
            "4": "#2B498B", 
            "5": "#4E886D", 
            "6": "#817FB3", 
            "7": "#CE7D28", 
            "8": "#96C4DA", 
            "9": "#A47E52", 
            "10": "#B6DD79" 
        };

        // Definir las estaciones de cada l√≠nea en orden
        const metroStations = {
            "1": [
            	"Castell√≥", "Alberic", "Massalav√©s", "Montortal", "L'Alc√∫dia", "Benimodo", "Carlet", "Ausi√†s March", "Alginet", "Font Almaguer", "Espioca", "Omet", "Picassent", "Sant Ramon", "Real√≥n", "Col¬∑legi El Vedat", "Torrent", "Pinanya", "Paiporta", "Val√®ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes√∫s", "Pl. Espanya", "√Ängel Guimer√†",
                "T√∫ria", "Campanar", "Beniferri", "Empalme", "Burjassot", "Burjassot - Godella",
                "Godella", "Rocafort", "Massarrojos", "Moncada - Alfara", "Seminari - CEU",
                "Masies", "Horta Vella", "B√©tera"
            ],
            "2": [
            	"Torrent Avinguda", "Torrent", "Pinanya", "Paiporta", "Val√®ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes√∫s", "Pl. Espanya", "√Ängel Guimer√†",
                "T√∫ria", "Campanar", "Beniferri", "Empalme", "Cantereria", "Benim√†met",
                "Les Carolines - Fira", "Campament", "Paterna", "Santa Rita", "Fuente del Jarro",
                "Font del Barranc", "La Canyada", "La Vallesa", "Entrepins", "El Clot", "Montesol",
                "L'Eliana", "Gallipont - Torre del Virrei", "La Pobla de Vallbona",
                "Fondo de Benaguasil", "Benaguasil", "Ll√≠ria"
            ],
            "3": [
                "Aeroport", "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", 
                "Mislata Almassil", "Mislata", "Nou d'Octubre", "Av. del Cid", "√Ängel Guimer√†", 
                "X√†tiva", "Col√≥n", "Alameda", "Facultats - Manuel Broseta", "Benimaclet", "Machado", 
                "Alboraia Palmaret", "Alboraia Peris Arag√≥", "Alm√†ssera", "Meliana", "Foios", 
                "Albalat dels Sorells", "Museros", "Massamagrell", "La Pobla de Farnals", "Rafelbunyol"
            ],

            "4": [
                "Dr. Lluch", "Platja les Arenes", "Cabanyal", "Platja Malva-rosa", "La Cadena", 
                "Beter√≥", "Tarongers - Ernest Lluch", "La Carrasca", "Universitat Polit√®cnica", 
                "Vicente Zaragoz√°", "Benimaclet", "Trinitat", "Pont de Fusta", "Sagunt", "Reus", 
                "Marxalenes", "Tr√†nsits", "Benicalap", "Garb√≠", "Florista", "Palau de Congressos", 
                "Empalme", "La Granja", "Sant Joan", "Campus", "Vicent Andr√©s Estell√©s", "√Ä Punt", 
                "Fira Val√®ncia", "Ll. Llarga - Terramelar", "Parc Cient√≠fic", "Tom√°s y Valiente", 
                "La Coma", "Mas del Rosari"
            ],
            "5": [
                "Aeroport", "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", 
                "Mislata Almassil", "Mislata", "Nou d'Octubre", "Av. del Cid", "√Ängel Guimer√†", 
                "X√†tiva", "Col√≥n", "Alameda", "Arag√≥", "Amistat", "Ayora", "Mar√≠tim"
            ],
            "6": [
                "Mar√≠tim", "Francesc Cubells", "Grau - La Marina", "Canyamelar", "Dr. Lluch", 
                "Cabanyal", "Platja les Arenes", "Platja Malva-rosa", "La Cadena", "Beter√≥", 
                "Tarongers - Ernest Lluch", "La Carrasca", "Universitat Polit√®cnica", 
                "Vicente Zaragoz√°", "Benimaclet", "Trinitat", "Alfauir", "Orriols", 
                "Estadi Ciutat de Val√®ncia", "Sant Miquel dels Reis", "Tossal del Rei"
            ],
            "7": [
            	"Torrent Avinguda", "Torrent", "Pinanya", "Paiporta", "Val√®ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes√∫s", "Bail√©n", "Col√≥n", "Alameda", 
                "Arag√≥", "Amistat", "Ayora", "Mar√≠tim"
            ],
            
            "8": [
                "Mar√≠tim", "Francesc Cubells", "Grau - La Marina", "Nept√∫"
                ],
            "9": [
                "Riba-roja de T√∫ria", "Masia de Traver", "Val√®ncia la Vella", "La Presa", "La Cova", 
                "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", "Mislata Almassil", 
                "Mislata", "Nou d'Octubre", "Av. del Cid", "√Ängel Guimer√†", "X√†tiva", "Col√≥n", 
                "Alameda", "Facultats - Manuel Broseta", "Benimaclet", "Machado", "Alboraia Palmaret", 
                "Alboraia Peris Arag√≥"
            ],
            "10": [
                "Bail√©n", "Alacant", "Russafa", "Amado Granell - Montolivet", "Quatre Carreres", 
                "Ciutat Arts i Ci√®ncies - Just√≠cia", "Oceanogr√†fic", "Moreres", "Natzaret"
            ]

        };

       
        document.getElementById('transport-select').addEventListener('change', function () {
            toggleTransport(this.value);
        });

        function toggleTransport(selectedType) {
            console.log("Filtrando transporte:", selectedType);

            markers.forEach(marker => map.removeLayer(marker));
            metroLinesPolylines.forEach(polyline => map.removeLayer(polyline));

            markers = [];
            metroLinesPolylines = [];

            if (selectedType !== "none") {
                pendingMarkers.forEach(marker => {
                    if (marker.tipo === selectedType) {
                        marker.addTo(map);
                        markers.push(marker);
                    }
                });

                if (selectedType === "metro") {
                    pendingPolylines.forEach(polyline => {
                        polyline.addTo(map);
                        metroLinesPolylines.push(polyline);
                    });
                }
            }
        }

        let metroLinesPolylines = []; // Guardamos aqu√≠ las l√≠neas dibujadas

  


        // Al cargar, todo est√° oculto por defecto
        
let pendingMarkers = []; // Array temporal para almacenar marcadores antes de mostrarlos
let pendingPolylines = []; // Array para l√≠neas de metro antes de mostrarlas

async function loadAllMetroStations(urls) {
    await Promise.all(urls.map(url => fetch(url).then(response => response.json())))
        .then(responses => {
            let allStations = responses.flatMap(data => data.results);
            processMetroStations(allStations);
        })
        .catch(error => console.error("Error cargando estaciones del metro:", error));
}

let metroCoordinates = {};
let stationUsage = {}; 

function processMetroStations(stations) {


    Object.keys(metroStations).forEach(linea => metroCoordinates[linea] = []);

    stations.forEach(station => {
        let lat = station.geo_point_2d.lat;
        let lon = station.geo_point_2d.lon;
        let name = station.nombre;
        let proximasLlegadas = station.proximas_llegadas;

        let marker = L.marker([lat, lon], {
            icon: createCustomIcon(20, "M", "red"),
        }).bindPopup(`<strong>${name}</strong><br><a href="${proximasLlegadas}" target="_blank">Pr√≥ximas llegadas</a>`);

        marker.tipo = "metro";
        pendingMarkers.push(marker); // Guardar en el array temporal, no en el mapa a√∫n

        Object.keys(metroStations).forEach(linea => {
            if (metroStations[linea].includes(name)) {
                if (!stationUsage[name]) {
                    stationUsage[name] = {name, lat, lon, lines: [] };
                }
                stationUsage[name].lines.push(linea);
                metroCoordinates[linea].push({ name, lat, lon });
            }
        });
    });

    Object.keys(metroStations).forEach(linea => {
        metroCoordinates[linea].sort((a, b) => metroStations[linea].indexOf(a.name) - metroStations[linea].indexOf(b.name));
        metroLines[linea] = metroCoordinates[linea];
    });

    drawMetroLines();
}



function drawMetroLines() {
	  pendingPolylines = []; // Reiniciar el array antes de dibujar

	  // 1. Contar la cantidad de apariciones de cada coordenada en todas las l√≠neas
	  let coordinateCounts = {};
	  Object.keys(metroLines).forEach(linea => {
	    metroLines[linea].forEach(coord => {
	      let key = `${coord.lat},${coord.lon}`;
	      coordinateCounts[key] = (coordinateCounts[key] || 0) + 1;
	    });
	  });

	  // Objeto para llevar el seguimiento del offset aplicado en cada coordenada
	  let positionOffset = {};

	  // 2. Dibujar cada l√≠nea aplicando offset solo en coordenadas compartidas por m√°s de una l√≠nea
	  Object.keys(metroLines).forEach(linea => {
	    if (metroLines[linea].length > 1) {
	      let coordinates = metroLines[linea];
	      let color = metroColors[linea] || "#000";

	      let adjustedCoordinates = coordinates.map(coord => {
	        let key = `${coord.lat},${coord.lon}`;
	        // Si la coordenada solo aparece en una l√≠nea, no se aplica offset
	        if (coordinateCounts[key] === 1) {
	          return { lat: coord.lat, lon: coord.lon };
	        }

	        // Si la coordenada es compartida, aplicamos un offset distinto para cada ocurrencia
	        if (!positionOffset[key]) {
	          positionOffset[key] = 0;
	        }
	        let offsetIndex = positionOffset[key]++;
	        let offsetAmount = 0.0010; // Ajusta el valor si es necesario
	        let angle = offsetIndex * (Math.PI / 6); // Variar direcci√≥n seg√∫n la ocurrencia
	        let latOffset = Math.sin(angle) * offsetAmount;
	        let lonOffset = Math.cos(angle) * offsetAmount;

	        return { lat: coord.lat + latOffset, lon: coord.lon + lonOffset };
	      });

	      let polyline = L.polyline(
	        adjustedCoordinates.map(coord => [coord.lat, coord.lon]),
	        {
	          color: color,
	          weight: 7,
	          opacity: 1
	        }
	      );

	      pendingPolylines.push(polyline); // Guardar la polil√≠nea en el array temporal
	    }
	  });
	}


 
function loadBusStations(url) {
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.results) {
                data.results.forEach(station => {
                    let lat = station.geo_point_2d.lat;
                    let lon = station.geo_point_2d.lon;
                    let denominacion = station.denominacion;
                    let lineas = station.lineas;
                    let proximasLlegadas = station.proximas_llegadas;

                    let marker = L.marker([lat, lon], {
                        icon: createCustomIcon(20, "B", "green"),
                    }).bindPopup(`<strong>${denominacion}<br> L√≠neas ${lineas}</strong><br><a href="${proximasLlegadas}" target="_blank">Pr√≥ximas llegadas</a>`);

                    marker.tipo = "bus"; 
                    pendingMarkers.push(marker); // Guardar en el array temporal
                });
            }
        });
}



function loadValenBiciStations(url) {
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.results) {
               // valenbisiStations = []; // Limpiar antes de cargar nuevas estaciones
                
                data.results.forEach(station => {
                    let lat = station.geo_point_2d.lat;
                    let lon = station.geo_point_2d.lon;
                    let address = station.address;
                    let available = station.available;
                    let total = station.total;

                    let marker = L.marker([lat, lon], {
                        icon: createCustomIcon(20, "V", "blue"),
                    }).bindPopup(`<strong>${address}</strong><br>Bicis disponibles: ${available} / ${total}`);

                    marker.tipo = "bici";
                    pendingMarkers.push(marker); // Guardar en el array temporal

                    // üìå Guardar la estaci√≥n en la lista global
                    valenbisiStations.push({ lat, lon, address, available, total });
                });
            }
        })
        .catch(error => console.error("Error al cargar estaciones de Valenbisi:", error));
}


const originInput = document.getElementById("origin-input");
const destinationInput = document.getElementById("destination-input");

const originAutocomplete = new google.maps.places.Autocomplete(originInput);
const destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput);

const minLat = 39.00, maxLat = 39.9;
const minLng = -0.75, maxLng = 0.1;

function isWithinBounds(latlng) {
    return (
        latlng.lat >= minLat && latlng.lat <= maxLat &&
        latlng.lng >= minLng && latlng.lng <= maxLng
    );
}

// Cuando se hace click en el bot√≥n "Establecer direcci√≥n"
document.getElementById("set-directions").addEventListener("click", function() {
	
  const originAddress = originInput.value;
  const destinationAddress = destinationInput.value;
  distancia_total = 0;
  segundos_total = 0;
  
   if (routePolyline) {
   	  routePolyline.forEach(item => {
   	    map.removeLayer(item);
   	  });
         routePolyline = [];
   	}
   
  if (!originAddress || !destinationAddress) {
    alert("Por favor, ingrese tanto origen como destino.");
    return;
  }

  const geocoder = new google.maps.Geocoder();

  // Geocode para la direcci√≥n de origen
  geocoder.geocode({ address: originAddress }, function(results, status) {//
    if (status === google.maps.GeocoderStatus.OK && results[0]) {
      const originLocation = results[0].geometry.location;
      // Convierte la posici√≥n de Google a un objeto LatLng de Leaflet
      pointA = L.latLng(originLocation.lat(), originLocation.lng());

      // Si ya existe un marker, se elimina
      if (markerA) {
        map.removeLayer(markerA);
      }
      
      if (!isWithinBounds(pointA)) {
          alert("La direcci√≥n de origen est√° fuera del √°rea permitida.");
          return;
      }
      
      markerA = createMarker(pointA, "red");

      // Geocode para la direcci√≥n de destino
      geocoder.geocode({ address: destinationAddress }, function(results2, status2) {
        if (status2 === google.maps.GeocoderStatus.OK && results2[0]) {
          const destinationLocation = results2[0].geometry.location;
          pointB = L.latLng(destinationLocation.lat(), destinationLocation.lng());

          
          if (!isWithinBounds(pointB)) {
              alert("La direcci√≥n de destino est√° fuera del √°rea permitida.");
              return;
          }
	        
          if (markerB) {
            map.removeLayer(markerB);
          }
          markerB = createMarker(pointB, "blue");

          document.getElementById("distance-info").innerText = "Origen y destino establecidos.";
          // Centrar el mapa entre ambos puntos
          moveToMidPointMarkers(pointA, pointB);

          // Opcional: Llama a la funci√≥n para calcular/dibujar la ruta seg√∫n la opci√≥n de transporte
          seleccionaOpcionTransporte();
        } else {
          alert("No se encontr√≥ la direcci√≥n de destino: " + status2);
        }
      });
    } else {
      alert("No se encontr√≥ la direcci√≥n de origen: " + status);
    }
  });
});


// Funci√≥n que espera a que todas las estaciones se carguen
async function loadAllData() {
    const urlsMetro = [
        "https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/fgv-estacions-estaciones/records?limit=100",
        "https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/fgv-estacions-estaciones/records?limit=42&offset=100"
    ];

    // Array de promesas de carga
    const promises = [
        loadAllMetroStations(urlsMetro),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=100"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=200"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=300"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=400"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=500"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=600"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=700"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=800"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=900"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=1000"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=26&offset=1100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=100&offset=100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=73&offset=200")
    ];

    // Esperar a que todas las promesas terminen
    await Promise.all(promises);

    // Una vez que todo est√© cargado, ocultar los transportes
    console.log("üöÄ Todas las estaciones cargadas, ocultando transportes");
    toggleTransport("none");
}

// Llamar a la funci√≥n que carga todo
loadAllData();



    </script>
</body>
</html>
