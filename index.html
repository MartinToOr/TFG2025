<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa de Valencia - Metro y Valenbisi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous">
<style>
    #map {
        width: 100%;
        height: 100vh;
        position: relative;
    }

    .logo { 
        height: 200px;
        width: auto;
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 1000; /* Asegura que est茅 encima del mapa */
        pointer-events: none; /* Permite clics en el mapa debajo */
    }

    .distance-info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
    }

    .transport-selector {
        position: absolute;
        top: 50px;
        right: 10px;
        background: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
    }
</style>
</head>
<body>
<div id="map"></div>
<div class="distance-info" id="distance-info">Seleccione dos puntos para calcular la distancia.</div>

<header>
    <img src="img/logo1.png" alt="Logo" class="logo">
</header>

<div class="transport-selector">
    <div class="control-panel">
        <label for="transport-select">Seleccionar una vista del mapa:</label>
        <select id="transport-select">
            <option value="none" selected>Mapa simple</option>
            <option value="metro">Metro</option>
            <option value="bus">Autobuses</option>
            <option value="bici">Valenbisi</option>
        </select>
    </div>
</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCzX88lbn1Xa_pouaPX4k_4IjRuJsjB064&libraries=geometry,places"></script>

    <script>
        let map = L.map('map', {
            minZoom: 10,
            maxBounds: [[39.35, -0.5], [39.6, -0.3]]
        }).setView([39.4699, -0.3763], 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '漏 OpenStreetMap contributors'
        }).addTo(map);

        let pointA = null;
        let pointB = null;
        let markerA = null;
        let markerB = null;
        let routePolyline = null;
        let markers = []; // Guarda todos los marcadores
        let valenbisiStations = []; // Almacenar estaciones de Valenbisi
        let transportMode = "TRANSIT";

        var directionsService = new google.maps.DirectionsService();
        var service = new google.maps.DistanceMatrixService();

        // Funci贸n para crear un marcador en Leaflet
        function createMarker(latlng, color) {
          return L.marker(latlng, {
            icon: L.icon({
              iconUrl: `https://maps.google.com/mapfiles/ms/icons/${color}-dot.png`,
              iconSize: [32, 32],
              iconAnchor: [16, 32]
            })
          }).addTo(map);
        }

        // Funci贸n principal que calcula distancias y rutas
        function calculateDistanceAndRoute() {
          if (!pointA || !pointB) return;

          const origin = new google.maps.LatLng(pointA.lat, pointA.lng);
          const destination = new google.maps.LatLng(pointB.lat, pointB.lng);

          if (transportMode === "COMPARA") {
            let modes = ["WALKING", "DRIVING", "BICYCLING"];
            let results = [];
            let completedRequests = 0;

            modes.forEach(mode => {
              const request = {
                origins: [origin],
                destinations: [destination],
                travelMode: google.maps.TravelMode[mode],
                unitSystem: google.maps.UnitSystem.METRIC
              };

              service.getDistanceMatrix(request, (response, status) => {
                if (status === "OK" && response.rows.length > 0) {
                  let element = response.rows[0].elements[0];
                  let distanceText = element.distance.text;
                  let durationText = element.duration.text;
                  let co2Emissions = mode === "DRIVING" ? "140g/km" : "0g/km";

                  let modeTranslation = {
                    "WALKING": "Andando",
                    "BICYCLING": "Bicicleta",
                    "DRIVING": "Coche"
                  };

                  results.push({ mode: modeTranslation[mode], distanceText, durationText, co2Emissions });
                } else {
                  console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
                }
                completedRequests++;
                if (completedRequests === modes.length) {
                  mostrarTablaResultados(results);
                }
              });
            });
          }
          else if (transportMode === "BICI") {
            if (!valenbisiStations || valenbisiStations.length === 0) {
              console.error("No hay estaciones de Valenbisi disponibles.");
              return;
            }

            // Aqu铆 todo el c贸digo dependiente de las estaciones se coloca dentro de la cadena de callbacks
            findNearestStationOptimized(pointA, function(startStation) {
              if (!startStation) {
                console.error("No se encontr贸 estaci贸n inicial cerca de pointA.");
                return;
              }
              console.log("startStation asignada:", startStation);

              findNearestStationOptimized(pointB, function(endStation) {
                if (!endStation) {
                  console.error("No se encontr贸 estaci贸n final cerca de pointB.");
                  return;
                }
                console.log("endStation asignada:", endStation);

                // Definir las rutas:
                let walkingRoute1 = { origin: pointA, destination: startStation };
                let cyclingRoute  = { origin: startStation, destination: endStation };
                let walkingRoute2 = { origin: endStation, destination: pointB };

                // Calcular y dibujar las rutas:
                calculateAndDrawRoute(walkingRoute1, "WALKING", "green");  // Desde pointA hasta la estaci贸n de inicio
                calculateAndDrawRoute(cyclingRoute,  "BICYCLING", "blue");   // En bici entre estaciones
                calculateAndDrawRoute(walkingRoute2, "WALKING", "green");    // Desde la estaci贸n final hasta pointB
              });
            });
          }
          else {
            // Resto de modos de transporte (por ejemplo, TRANSIT, DRIVING, etc.)
            const distanceRequest = {
              origins: [origin],
              destinations: [destination],
              travelMode: google.maps.TravelMode[transportMode] || "TRANSIT",
              unitSystem: google.maps.UnitSystem.METRIC
            };

            service.getDistanceMatrix(distanceRequest, (response, status) => {
              if (status === "OK" && response.rows.length > 0) {
                let distanceText = response.rows[0].elements[0].distance.text;
                document.getElementById('distance-info').innerText = `Distancia: ${distanceText}`;
              } else {
                console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
              }
            });

            const directionsRequest = {
              origin: origin,
              destination: destination,
              travelMode: google.maps.TravelMode[transportMode] || "TRANSIT"
            };

            directionsService.route(directionsRequest, (result, status) => {
              if (status === "OK") {
                if (routePolyline) {
                  map.removeLayer(routePolyline);
                }
                const routeCoords = result.routes[0].overview_path.map(point => [point.lat(), point.lng()]);
                routePolyline = L.polyline(routeCoords, { color: 'blue', weight: 4 }).addTo(map);
              } else {
                console.error("Error al obtener la ruta de Google Maps Directions:", status);
              }
            });
          }
        }

        // Funci贸n para calcular y dibujar una ruta usando Directions y Distance Matrix
        function calculateAndDrawRoute(route, mode, color) {
          // Convertir y validar las coordenadas
          const originLat = parseFloat(route.origin.lat);
          const originLng = parseFloat(route.origin.lng);
          const destinationLat = parseFloat(route.destination.lat);
          const destinationLng = parseFloat(route.destination.lng);

          if (isNaN(originLat) || isNaN(originLng) || isNaN(destinationLat) || isNaN(destinationLng)) {
            console.error("Coordenadas inv谩lidas en la ruta:", route);
            return;
          }

          const request = {
            origin: new google.maps.LatLng(originLat, originLng),
            destination: new google.maps.LatLng(destinationLat, destinationLng),
            travelMode: google.maps.TravelMode[mode]
          };

          let distancia_total = ""; // Inicializamos la variable

          // Usar route.origin y route.destination (ya convertidos) en la solicitud
          const distanceRequest = {
            origins: [new google.maps.LatLng(originLat, originLng)],
            destinations: [new google.maps.LatLng(destinationLat, destinationLng)],
            travelMode: google.maps.TravelMode[mode],
            unitSystem: google.maps.UnitSystem.METRIC
          };

          service.getDistanceMatrix(distanceRequest, (response, status) => {
            if (status === "OK" && response.rows.length > 0) {
              let distanceText = response.rows[0].elements[0].distance.text;
              console.log(distanceText);
              distancia_total = distanceText;
              document.getElementById('distance-info').innerText = `Distancia: ${distancia_total}`;
            } else {
              console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
            }
          });

          directionsService.route(request, (result, status) => {
            if (status === "OK") {
              let routeCoords = result.routes[0].overview_path.map(point => [point.lat(), point.lng()]);
              L.polyline(routeCoords, { color: color, weight: 4 }).addTo(map);
            } else {
              console.error(`Error al calcular ruta (${mode}):`, status);
            }
          });
        }

        // Funci贸n para buscar la estaci贸n de Valenbisi m谩s cercana (usando 3 candidatos aproximados)
        function findNearestStationOptimized(point, callback) {
          // 1. Calcular la distancia aproximada para cada estaci贸n usando la f贸rmula de haversine
          const candidates = valenbisiStations
            .map(station => {
              // Convertir las coordenadas de la estaci贸n (normalizamos: usamos station.lat y station.lon -> station.lng)
              const candidateCoord = { lat: parseFloat(station.lat), lng: parseFloat(station.lon) };
              const approxDistance = haversineDistance(point, candidateCoord);
              return { station, approxDistance };
            })
            .sort((a, b) => a.approxDistance - b.approxDistance)
            .slice(0, 3);

          console.log("Candidatos aproximados (por haversine):");
          candidates.forEach(candidate => {
            console.log(`${candidate.station.address} - ${candidate.approxDistance.toFixed(5)} km`);
          });

          const originLatLng = new google.maps.LatLng(point.lat, point.lng);
          const destinations = candidates.map(candidate =>
            new google.maps.LatLng(parseFloat(candidate.station.lat), parseFloat(candidate.station.lon))
          );

          const distanceRequest = {
            origins: [originLatLng],
            destinations: destinations,
            travelMode: google.maps.TravelMode.WALKING,
            unitSystem: google.maps.UnitSystem.METRIC
          };

          service.getDistanceMatrix(distanceRequest, (response, status) => {
            if (status === "OK" && response.rows.length > 0) {
              const elements = response.rows[0].elements;
              let bestIndex = -1;
              let bestDistance = Infinity;

              elements.forEach((element, index) => {
                if (element.status === "OK") {
                  const walkingDistance = element.distance.value; // en metros
                  console.log(`Distancia caminando a ${candidates[index].station.address}: ${walkingDistance} m`);
                  if (walkingDistance < bestDistance) {
                    bestDistance = walkingDistance;
                    bestIndex = index;
                  }
                } else {
                  console.warn(`No se pudo obtener la distancia para ${candidates[index].station.address}`);
                }
              });

              if (bestIndex !== -1) {
                const bestStation = candidates[bestIndex].station;
                // Normalizamos el objeto de estaci贸n (convertimos 'lon' en 'lng')
                const normalizedStation = {
                  lat: bestStation.lat,
                  lng: bestStation.lon,
                  address: bestStation.address,
                  available: bestStation.available,
                  total: bestStation.total
                };
                console.log(`La estaci贸n m谩s cercana es: ${normalizedStation.address} (${bestDistance} m caminando)`);
                callback(normalizedStation);
              } else {
                console.error("No se pudo determinar la estaci贸n m谩s cercana a partir de la respuesta de Google.");
                callback(null);
              }
            } else {
              console.error("Error en la solicitud a Google Maps Distance Matrix:", status);
              callback(null);
            }
          });
        }

        // Funci贸n que calcula la distancia entre dos coordenadas (usando la f贸rmula de haversine)
        function haversineDistance(coord1, coord2) {
          const R = 6371; // Radio de la Tierra en km
          const dLat = (parseFloat(coord2.lat) - parseFloat(coord1.lat)) * Math.PI / 180;
          const dLon = (parseFloat(coord2.lng) - parseFloat(coord1.lng)) * Math.PI / 180;
          const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(parseFloat(coord1.lat) * Math.PI / 180) * Math.cos(parseFloat(coord2.lat) * Math.PI / 180) *
                    Math.sin(dLon / 2) ** 2;
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }



        map.on('click', function (e) {
            if (!pointA) {
                pointA = e.latlng;
                markerA = createMarker(pointA, "red");
            } else if (!pointB) {
                pointB = e.latlng;
                markerB = createMarker(pointB, "blue");
                seleccionaOpcionTransporte();
            } else {
             
                map.removeLayer(markerA);
                map.removeLayer(markerB);
                pointB = null;
                pointA = null;
               
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                    routePolyline = null;
                }
                document.getElementById('distance-info').innerText = "Seleccione un nuevo punto B.";
            }
        });

        
        
        map.on('zoomend', function () {
            let zoom = map.getZoom();
            let size = zoom < 10 ? 7    
                     : zoom < 13 ? 10
                     : zoom < 14 ? 13
                     : zoom < 15 ? 19
                     : 25;  

            markers.forEach(marker => {
                let color = marker.tipo === "metro" ? "red" :
                            marker.tipo === "bus" ? "green" : "blue";

                let letter = marker.tipo === "metro" ? "M" :
                             marker.tipo === "bus" ? "B" : "V";

                marker.setIcon(createCustomIcon(size, letter, color));
            });
        });
        
        
        function seleccionaOpcionTransporte() {
            // Crear el modal
            let modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.display = "flex";
            modal.style.justifyContent = "center";
            modal.style.alignItems = "center";
            modal.style.zIndex = "9999"; // Asegurar que est谩 delante de todo

            let modalContent = document.createElement("div");
            modalContent.style.background = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "10px";
            modalContent.style.textAlign = "center";
            modalContent.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";

            let title = document.createElement("h3");
            title.innerText = "Selecciona un modo de transporte";
            modalContent.appendChild(title);

            let botones = [
                { texto: "Andando", valor: "WALKING" },
                { texto: "Coche", valor: "DRIVING" },
                { texto: "Bicicleta", valor: "BICYCLING" },
                { texto: "Metro", valor: "METRO" },
                { texto: "Autobus", valor: "BUS" },
                { texto: "Valenbici", valor: "BICI" },
                { texto: "Comparalos todos", valor: "COMPARA" }
            ];

            botones.forEach(boton => {
                let btn = document.createElement("button");
                btn.innerText = boton.texto;
                btn.style.margin = "10px";
                btn.style.padding = "10px 20px";
                btn.style.border = "none";
                btn.style.cursor = "pointer";
                btn.style.borderRadius = "5px";
                btn.style.background = "#007bff";
                btn.style.color = "white";
                btn.onclick = function() {
                    transportMode = boton.valor;
                    document.body.removeChild(modal);
                    calculateDistanceAndRoute();
                };
                modalContent.appendChild(btn);
            });

            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
        
        
        function mostrarTablaResultados(results) {
            let modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.display = "flex";
            modal.style.justifyContent = "center";
            modal.style.alignItems = "center";
            modal.style.zIndex = "9999";

            let modalContent = document.createElement("div");
            modalContent.style.background = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "10px";
            modalContent.style.textAlign = "center";
            modalContent.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";

            let title = document.createElement("h3");
            title.innerText = "Comparaci贸n de modos de transporte";
            modalContent.appendChild(title);

            let table = document.createElement("table");
            table.style.width = "100%";
            table.style.borderCollapse = "collapse";
            table.style.marginTop = "20px";

            let thead = document.createElement("thead");
            let headerRow = document.createElement("tr");
            ["Modo de Transporte", "Distancia", "Tiempo", "CO2 Emitido"].forEach(text => {
                let th = document.createElement("th");
                th.innerText = text;
                th.style.border = "1px solid #ddd";
                th.style.padding = "10px";
                th.style.background = "#f4f4f4";
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            let tbody = document.createElement("tbody");
            results.forEach(result => {
                let row = document.createElement("tr");
                [result.mode, result.distanceText, result.durationText, result.co2Emissions].forEach(value => {
                    let td = document.createElement("td");
                    td.innerText = value;
                    td.style.border = "1px solid #ddd";
                    td.style.padding = "10px";
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            modalContent.appendChild(table);
            
            let closeButton = document.createElement("button");
            closeButton.innerText = "Cerrar";
            closeButton.style.marginTop = "15px";
            closeButton.onclick = () => document.body.removeChild(modal);
            modalContent.appendChild(closeButton);
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
        
        function createCustomIcon(size, letter, color) {
            return L.divIcon({
                className: 'custom-icon',
                html: `<div style="
                            width: ${size}px;
                            height: ${size}px;
                            background: ${color};
                            color: white;
                            text-align: center;
                            font-weight: bold;
                            font-size: ${size / 2}px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;">
                        ${letter}
                    </div>`,
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });
        }
        
        let metroLines = {}; 
        const metroColors = {
            "1": "#E4BE36", 
            "2": "#B4397F", 
            "3": "#B11D2F", 
            "4": "#2B498B", 
            "5": "#4E886D", 
            "6": "#817FB3", 
            "7": "#CE7D28", 
            "8": "#96C4DA", 
            "9": "#A47E52", 
            "10": "#B6DD79" 
        };

        // Definir las estaciones de cada l铆nea en orden
        const metroStations = {
            "1": [
            	"Castell贸", "Alberic", "Massalav茅s", "Montortal", "L'Alc煤dia", "Benimodo", "Carlet", "Ausis March", "Alginet", "Font Almaguer", "Espioca", "Omet", "Picassent", "Sant Ramon", "Real贸n", "Col路legi El Vedat", "Torrent", "Pinanya", "Paiporta", "Val猫ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes煤s", "Pl. Espanya", "ngel Guimer",
                "T煤ria", "Campanar", "Beniferri", "Empalme", "Burjassot", "Burjassot - Godella",
                "Godella", "Rocafort", "Massarrojos", "Moncada - Alfara", "Seminari - CEU",
                "Masies", "Horta Vella", "B茅tera"
            ],
            "2": [
            	"Torrent Avinguda", "Torrent", "Pinanya", "Paiporta", "Val猫ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes煤s", "Pl. Espanya", "ngel Guimer",
                "T煤ria", "Campanar", "Beniferri", "Empalme", "Cantereria", "Benimmet",
                "Les Carolines - Fira", "Campament", "Paterna", "Santa Rita", "Fuente del Jarro",
                "Font del Barranc", "La Canyada", "La Vallesa", "Entrepins", "El Clot", "Montesol",
                "L'Eliana", "Gallipont - Torre del Virrei", "La Pobla de Vallbona",
                "Fondo de Benaguasil", "Benaguasil", "Ll铆ria"
            ],
            "3": [
                "Aeroport", "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", 
                "Mislata Almassil", "Mislata", "Nou d'Octubre", "Av. del Cid", "ngel Guimer", 
                "Xtiva", "Col贸n", "Alameda", "Facultats - Manuel Broseta", "Benimaclet", "Machado", 
                "Alboraia Palmaret", "Alboraia Peris Arag贸", "Almssera", "Meliana", "Foios", 
                "Albalat dels Sorells", "Museros", "Massamagrell", "La Pobla de Farnals", "Rafelbunyol"
            ],

            "4": [
                "Dr. Lluch", "Platja les Arenes", "Cabanyal", "Platja Malva-rosa", "La Cadena", 
                "Beter贸", "Tarongers - Ernest Lluch", "La Carrasca", "Universitat Polit猫cnica", 
                "Vicente Zaragoz谩", "Benimaclet", "Trinitat", "Pont de Fusta", "Sagunt", "Reus", 
                "Marxalenes", "Trnsits", "Benicalap", "Garb铆", "Florista", "Palau de Congressos", 
                "Empalme", "La Granja", "Sant Joan", "Campus", "Vicent Andr茅s Estell茅s", " Punt", 
                "Fira Val猫ncia", "Ll. Llarga - Terramelar", "Parc Cient铆fic", "Tom谩s y Valiente", 
                "La Coma", "Mas del Rosari"
            ],
            "5": [
                "Aeroport", "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", 
                "Mislata Almassil", "Mislata", "Nou d'Octubre", "Av. del Cid", "ngel Guimer", 
                "Xtiva", "Col贸n", "Alameda", "Arag贸", "Amistat", "Ayora", "Mar铆tim"
            ],
            "6": [
                "Mar铆tim", "Francesc Cubells", "Grau - La Marina", "Canyamelar", "Dr. Lluch", 
                "Cabanyal", "Platja les Arenes", "Platja Malva-rosa", "La Cadena", "Beter贸", 
                "Tarongers - Ernest Lluch", "La Carrasca", "Universitat Polit猫cnica", 
                "Vicente Zaragoz谩", "Benimaclet", "Trinitat", "Alfauir", "Orriols", 
                "Estadi Ciutat de Val猫ncia", "Sant Miquel dels Reis", "Tossal del Rei"
            ],
            "7": [
            	"Torrent Avinguda", "Torrent", "Pinanya", "Paiporta", "Val猫ncia Sud", "Sant Isidre", "Safranar", "Patraix", "Jes煤s", "Bail茅n", "Col贸n", "Alameda", 
                "Arag贸", "Amistat", "Ayora", "Mar铆tim"
            ],
            
            "8": [
                "Mar铆tim", "Francesc Cubells", "Grau - La Marina", "Nept煤"
                ],
            "9": [
                "Riba-roja de T煤ria", "Masia de Traver", "Val猫ncia la Vella", "La Presa", "La Cova", 
                "Roses", "Manises", "Salt de l'Aigua", "Quart de Poblet", "Faitanar", "Mislata Almassil", 
                "Mislata", "Nou d'Octubre", "Av. del Cid", "ngel Guimer", "Xtiva", "Col贸n", 
                "Alameda", "Facultats - Manuel Broseta", "Benimaclet", "Machado", "Alboraia Palmaret", 
                "Alboraia Peris Arag贸"
            ],
            "10": [
                "Alacant", "Russafa", "Amado Granell - Montolivet", "Quatre Carreres", 
                "Ciutat Arts i Ci猫ncies - Just铆cia", "Oceanogrfic", "Moreres", "Natzaret"
            ]

        };

       
        document.getElementById('transport-select').addEventListener('change', function () {
            toggleTransport(this.value);
        });

        function toggleTransport(selectedType) {
            console.log("Filtrando transporte:", selectedType);

            markers.forEach(marker => map.removeLayer(marker));
            metroLinesPolylines.forEach(polyline => map.removeLayer(polyline));

            markers = [];
            metroLinesPolylines = [];

            if (selectedType !== "none") {
                pendingMarkers.forEach(marker => {
                    if (marker.tipo === selectedType) {
                        marker.addTo(map);
                        markers.push(marker);
                    }
                });

                if (selectedType === "metro") {
                    pendingPolylines.forEach(polyline => {
                        polyline.addTo(map);
                        metroLinesPolylines.push(polyline);
                    });
                }
            }
        }

        let metroLinesPolylines = []; // Guardamos aqu铆 las l铆neas dibujadas

  


        // Al cargar, todo est谩 oculto por defecto
        
let pendingMarkers = []; // Array temporal para almacenar marcadores antes de mostrarlos
let pendingPolylines = []; // Array para l铆neas de metro antes de mostrarlas

async function loadAllMetroStations(urls) {
    await Promise.all(urls.map(url => fetch(url).then(response => response.json())))
        .then(responses => {
            let allStations = responses.flatMap(data => data.results);
            processMetroStations(allStations);
        })
        .catch(error => console.error("Error cargando estaciones del metro:", error));
}

function processMetroStations(stations) {
    let metroCoordinates = {};
    let stationUsage = {}; 

    Object.keys(metroStations).forEach(linea => metroCoordinates[linea] = []);

    stations.forEach(station => {
        let lat = station.geo_point_2d.lat;
        let lon = station.geo_point_2d.lon;
        let name = station.nombre;
        let proximasLlegadas = station.proximas_llegadas;

        let marker = L.marker([lat, lon], {
            icon: createCustomIcon(20, "M", "red"),
        }).bindPopup(`<strong>${name}</strong><br><a href="${proximasLlegadas}" target="_blank">Pr贸ximas llegadas</a>`);

        marker.tipo = "metro";
        pendingMarkers.push(marker); // Guardar en el array temporal, no en el mapa a煤n

        Object.keys(metroStations).forEach(linea => {
            if (metroStations[linea].includes(name)) {
                if (!stationUsage[name]) {
                    stationUsage[name] = { lat, lon, lines: [] };
                }
                stationUsage[name].lines.push(linea);
                metroCoordinates[linea].push({ name, lat, lon });
            }
        });
    });

    Object.keys(metroStations).forEach(linea => {
        metroCoordinates[linea].sort((a, b) => metroStations[linea].indexOf(a.name) - metroStations[linea].indexOf(b.name));
        metroLines[linea] = metroCoordinates[linea];
    });

    drawMetroLines();
}



 function drawMetroLines() {
	    pendingPolylines = []; // Reiniciar el array antes de dibujar
	    let positionOffset = {}; // Almacenar el n煤mero de l铆neas en cada coordenada

	    Object.keys(metroLines).forEach(linea => {
	        if (metroLines[linea].length > 1) {
	            let coordinates = metroLines[linea];
	            let color = metroColors[linea] || "#000";


	            let adjustedCoordinates = coordinates.map(coord => {
	                let key = `${coord.lat},${coord.lon}`;

	                if (!positionOffset[key]) {
	                    positionOffset[key] = 0; // Primera vez que se usa esta coordenada
	                }

	                let offsetIndex = positionOffset[key]++;
	                let offsetAmount = 0.0003; // Ajusta el valor si es necesario
	                let angle = (offsetIndex * (Math.PI / 6)); // Variar direcci贸n
	                let latOffset = Math.sin(angle) * offsetAmount;
	                let lonOffset = Math.cos(angle) * offsetAmount;

	                return { lat: coord.lat + latOffset, lon: coord.lon + lonOffset };
	            });

	            let polyline = L.polyline(adjustedCoordinates.map(coord => [coord.lat, coord.lon]), {
	                color: color,
	                weight: 4,
	                opacity: 0.8
	            });

	            pendingPolylines.push(polyline); // Guardar en el array temporal
	        }
	    });
	}

 
function loadBusStations(url) {
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.results) {
                data.results.forEach(station => {
                    let lat = station.geo_point_2d.lat;
                    let lon = station.geo_point_2d.lon;
                    let denominacion = station.denominacion;
                    let lineas = station.lineas;
                    let proximasLlegadas = station.proximas_llegadas;

                    let marker = L.marker([lat, lon], {
                        icon: createCustomIcon(20, "B", "green"),
                    }).bindPopup(`<strong>${denominacion}<br> L铆neas ${lineas}</strong><br><a href="${proximasLlegadas}" target="_blank">Pr贸ximas llegadas</a>`);

                    marker.tipo = "bus"; 
                    pendingMarkers.push(marker); // Guardar en el array temporal
                });
            }
        });
}



function loadValenBiciStations(url) {
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.results) {
               // valenbisiStations = []; // Limpiar antes de cargar nuevas estaciones
                
                data.results.forEach(station => {
                    let lat = station.geo_point_2d.lat;
                    let lon = station.geo_point_2d.lon;
                    let address = station.address;
                    let available = station.available;
                    let total = station.total;

                    let marker = L.marker([lat, lon], {
                        icon: createCustomIcon(20, "V", "blue"),
                    }).bindPopup(`<strong>${address}</strong><br>Bicis disponibles: ${available} / ${total}`);

                    marker.tipo = "bici";
                    pendingMarkers.push(marker); // Guardar en el array temporal

                    //  Guardar la estaci贸n en la lista global
                    valenbisiStations.push({ lat, lon, address, available, total });
                });
            }
        })
        .catch(error => console.error("Error al cargar estaciones de Valenbisi:", error));
}

// Funci贸n que espera a que todas las estaciones se carguen
async function loadAllData() {
    const urlsMetro = [
        "https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/fgv-estacions-estaciones/records?limit=100",
        "https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/fgv-estacions-estaciones/records?limit=42&offset=100"
    ];

    // Array de promesas de carga
    const promises = [
        loadAllMetroStations(urlsMetro),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=100"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=200"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=300"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=400"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=500"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=600"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=700"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=800"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=900"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=100&offset=1000"),
        loadBusStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/emt/records?limit=26&offset=1100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=100&offset=100"),
        loadValenBiciStations("https://valencia.opendatasoft.com/api/explore/v2.1/catalog/datasets/valenbisi-disponibilitat-valenbisi-dsiponibilidad/records?limit=73&offset=200")
    ];

    // Esperar a que todas las promesas terminen
    await Promise.all(promises);

    // Una vez que todo est茅 cargado, ocultar los transportes
    console.log(" Todas las estaciones cargadas, ocultando transportes");
    toggleTransport("none");
}

// Llamar a la funci贸n que carga todo
loadAllData();



    </script>
</body>
</html>
